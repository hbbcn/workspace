一、final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。
    一旦你将引用声明作final，你将不能改变这个引用了，编译器会检查代码，如果你试图将变量再次初始化的话，编译器会报编译错误。
1、final修饰变量
　　final成员变量表示常量，只能被赋值一次，赋值后值不再改变（final要求地址值不能改变）
　　当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；
    如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。
    本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。
　　final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式，一种是在变量声明的时候初始化；
    第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。
2、final方法
    使用final方法的原因有两个。
    第一个原因是把方法锁定，以防任何继承类修改它的含义，不能被重写；
    第二个原因是效率，final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。
（注：类的private方法会隐式地被指定为final方法）
3、final类
    当用final修饰一个类时，表明这个类不能被继承。
    final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。
    在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类

二、标识符：在Java中凡是自己可以起名字的地方都叫标识符
    命名规则：
    1、只能包含字母、数字、下划线、$
    2、数字不能开头
    3、不能包含Java的关键字、保留字
    4、标识符没有长度限制；
    5、标识符对大小写敏感。

三、
    1、私有方法不能被重写,此方法只属于这个类的
    2、如果父类的方法不是私有的，子类方法名和父类方法名只要相同,参数类型相同，子类就需要重写父类方法，则返回类型一定相同
       子类的方法权限修饰符必须大于或者等于父类方法的权限修饰符
    3、重载方法名相同，返回类型可以相同也可以不相同(不能通过返回类型判断是否重载)，参数类型不同或参数个数不同
       参数顺序不同。
    4、重载和重写的区别
    方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
    重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；
    重写发生在子类与父类之间，重写要求子类重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，
    比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，
    不能根据返回类型进行区分。

    方法重写的返回值类型
    特别注意：有一种流行说法叫 一大、两小、两同
    两小就包含了 返回值类型要小于或等于被重写的方法
    这个小于要特别注意 仅仅是对与返回值类型为“类”时，
    比如  A 是Word的子类
    那么重写是 如果父类方法返回Word类型,子类可以返回A或Word类型

四、throw和throws的区别
throw:
    ① 用在方法体内，后面跟的是异常类对象名
    ② 只能抛出一个异常对象名
    ③ 表示抛出异常，由方法体内的语句来处理
    ④ throw则是抛出异常，执行throw一定出现了某种异常

throws
    ① 跟在方法声明后面，后面跟的是异常类对象名
    ② 可以跟多个异常类名，用逗号隔开
    ③ 表示抛出异常，由该方法的调用者来处理
    ④ 表示有出现异常的可能性，并不一定出现这些异常

五、Collection和Collections的区别
1、Collection是一个接口，它提供了对集合对象进行基本操作的通用的接口方法

2、Collections则是集合类的一个工具类，其中提供了一系列静态方法，用于对集合中元素进行排序
搜索以及线程安全等各种操作。

六、
1、子类写的私有方法和父类的私有方法一样的话，不叫重写
2、静态代码块：用static声明，jvm加载类执行，仅执行一次
   构造代码块：类中直接用{}定义，每一次创建对象时执行
   执行顺序优先级：静态代码块，构造代码块  构造方法

   构造代码块：构造代码块的作用是给对象进行初始化，
   构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块。
   构造函数：是给与之对应的对象进行初始化。它具有针对性。
   构造代码块与构造函数的区别是：构造代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化。
3、执行构造函数检查是否有父类，如果有父类会先调用父类的构造函数，这里假设 Dog 没有父类，
   执行默认值字段的赋值即方法的初始化动作。

七、java中各个类型的取值范围和默认值
    ·byte属于java中的整型，长度为1字节8bit,取值是10000000(-128)到01111111(127),变量初始化默认值为0，包装类Byte
    ·short属于java中的整型，长度为2个字节 取值10000000 00000000（-32768） 到
      01111111 1111111(32767)变量初始化值为0
    ·int属于Java的整型，长度4字节，取值-2^31到 2^31-1 变量初始化默认值为0，包装类Integer
    ·long属于java中的整型，长度为8字节,变量初始化默认值为0或0L,包装类Long
    ·float属于java中的浮点型，也叫单精度浮点型，长度4字节，变量初始化默认值0.0f
    ·double属于Java中的浮点型，也叫双精度浮点型，长度为8字节，变量初始化默认值0.0d
    ·char属于Java中的字符型，占2字节16位，包装类Character
    ·boolean在JVM中并没有提供专用的字节码指令，而boolean类型数据在经过编译后在JVM会通过int类型来表示
     此时boolean数据4字节,无默认值 缺省值位‘\u0000’ NUL


八、
1、Integer 赋予的int数值在-128 - 127的时候，直接从***中获取，这些***引用对Integer对象地址是不变的，但是不在这个范围内的数字，
   则new Integer(i) 这个地址是新的地址，不可能一样的.
2、值传递：在方法调用时，传递的参数是按值的拷贝传递。
   八大数据类型都是值传递
   引用传递：在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。
   数组和引用类型都是引用传递,String Integer是不可变的。

3、java在序列化时不会实例化static变量和transient修饰的变量，因为static代表类的成员，transient代表对象的临时数据，
被声明这两种类型的数据成员不能被序列化

4、只有类才存在静态的变量 方法只能对静态变量的操作 不能在方法内试图定义静态变量
    因为static只能修饰成员变量和成员方法，在局部变量中用static修饰，又不能直接被类调用，
    而static关键字就是不直接过对象而用类就可以直接调用的，所以局部变量前不能加static关键字

    定义在方法中的变量叫局部变量，局部变量的有效范围就是方法内，在局部变量中加上public，或者其他修饰符的话（编译都通不过），
    就破坏了局部变量的范围，可以说局部变量是为方法而生的。局部变量中的局部就已经说明了范围

5、TLS技术：

   同一全局变量或者静态变量每个线程访问的是同一变量，多个线程同时访存同一全局变量或者静态变量时会导致冲突，尤其是多个线程同时需要修改这一变量时。
  通过TLS机制，为每一个使用该全局变量的线程都提供一个变量值的副本，每一个线程均可以独立地改变自己的副本，而不会和其它线程的副本冲突。
   1.解决多线程中的对同一变量的访问冲突的一种技术;
   2.TLS会为每一个线程维护一个和该线程绑定的变量的副本;
   3.Java平台的java.lang.ThreadLocal是TLS技术的一种实现;
   ThreadLocal：
   ThreadLocal存放的值是线程封闭，线程间互斥；
   ThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本;
   主要用于线程内共享一些数据，避免通过参数来传递;
   ThreadLocal保证各个线程间数据安全，每个线程的数据不会被另外线程访问和破坏;
   Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离；
   ThreadLocal与Thread，Runnable没有啥关系
   ThreadLocal的使用场景：
   数据库连接：在多线程中，如果使用懒汉式的单例模式创建Connection对象，由于该对象是共享的，
   那么必须要使用同步方法保证线程安全，这样当一个线程在连接数据库时，那么另外一个线程只能等待。
   这样就造成性能降低。如果改为哪里要连接数据库就来进行连接，那么就会频繁的对数据库进行连接，
   性能还是不高。这时使用ThreadLocal就可以既可以保证线程安全又可以让性能不会太低。
   但是ThreadLocal的缺点时占用了较多的空间。


字符串常量拼接在编译期间就已经完成，“+”号操作时在编译时期完成的
字符串引用拼接是运行时执行，“+”号操作时运行时执行的。结果在堆中

如果字符串拼接中有变量则结果不会进入字符串常量池）
调用String的intern方法可以将String存入字符串常量池

常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息
运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址
运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得
的方法或者字段引用。 此时不再是常量池中的符号地址了，这里换为真实地址。
常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象，
当执行的时候就会被加载进去。

JDK1.7及之前方法区位于永久代.由于一些原因在JDK1.8之后彻底祛除了永久代,用元空间代替.所以运行时常量池一直是方法区的一部分。


关于Iterator主要有三个方法：hasNext()、next()、remove()
  hasNext:没有指针下移操作，只是判断是否存在下一个元素
  next：指针下移，返回该指针所指向的元素
  remove：删除当前指针所指向的元素，一般和next方法一起用，这时候的作用就是删除next方法返回的元素

Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。
而Comparator是比较器；我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。
我们不难发现：Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。


Comparable 简介
Comparable 是排序接口。
若一个类实现了Comparable接口，就意味着“该类支持排序”。此外，“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器。
接口中通过x.compareTo(y)来比较x和y的大小。若返回负数，意味着x比y小；返回零，意味着x等于y；返回正数，意味着x大于y。

Comparator 简介
Comparator 是比较器接口。我们若需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)；
那么，我们可以建立一个“该类的比较器”来进行排序。这个“比较器”只需要实现Comparator接口即可。
也就是说，我们可以通过“实现Comparator类来新建一个比较器”，然后通过该比较器对类进行排序。
int compare(T o1, T o2)和上面的x.compareTo(y)类似，定义排序规则后返回正数，零和负数分别代表大于，
等于和小于。
两者的联系
Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。


继承是多态的前提，多态的使用：只能调用父类方法和子类重写父类的方法，不能调用子类特有的方法
如果要调用子类特有的方法，可以向下转型


5、volatile和synchronized区别
1）volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量
只有当前线程可以访问该变量,其他线程被阻塞住.
2）volatile仅能使用在变量级别,synchronized则可以使用在变量,方法
3）volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性.
《Java编程思想》上说，定义long或double变量时，如果使用volatile关键字，
就会获得（简单的赋值与返回操作）原子性。 　
4）volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.
5)、当一个域的值依赖于它之前的值时，volatile就无法工作了，如n=n+1,n++等。
如果某个域的值受到其他域的值的限制，那么volatile也无法工作，如Range类的lower和upper边界，
必须遵循lower<=upper的限制。
6)、使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。
volatile和synchronized的区别
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；
synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化
6、synchronized和lock区别
　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；
　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；
而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；
　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。
　  5）Lock可以提高多个线程进行读操作的效率。
　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），
此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择


synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；而lock发生异常时候，不会主动释放占有的锁
必须手动unlock来释放锁，可能引起死锁的发生。（所以最好将同步代码块用try catch包起来，finally中写入unlock，避免死锁的发生。）
是否响应中断
lock等待锁过程中可以用interrupt来中断等待，而synchronized只能等待锁的释放，不能响应中断；
是否知道获取锁
Lock可以通过tryLock来知道有没有获取锁，而synchronized不能；


  Lock是一个接口，而synchronized是关键字。
  synchronized会自动释放锁，而Lock必须手动释放锁。
  Lock可以让等待锁的线程响应中断，而synchronized不会，线程会一直等待下去。
  通过Lock可以知道线程有没有拿到锁，而synchronized不能。
  Lock能提高多个线程读操作的效率。
  synchronized能锁住类、方法和代码块，而Lock是块范围内的


synchronized：
    是一个关键字，作用在类或者对象上。一旦线程A获取到锁，B就需要一直等待直到A释放了锁
所以它是不可中断的，这样子影响效率。使用该关键字，不知道是否获取成功获取到锁。
是可重入锁，意思是：假如两个方法method1和method2，都用synchronized修饰，
然后在method1中调用method2。调用method1，获取到当前对象锁，执行method2的话不需要再次获取锁了。
如果需要的话，就会造成一直请求不到锁的情况。它会在执行完毕或者执行异常的时候，自动释放锁。
Lock:是一个接口。它允许在等待一段时间后中断等待，而且可以返回是否成功获取锁了。
Lock需要手动去释放锁，否则可能会导致死锁。它有一个实现类：ReentranLock（可重入）。
有其他几个类：ReadWriteLock、ReentrantReadWriteLock。
Lock可以提高多个线程进行读操作的效率。
=概念解析=

1、可重入锁：基于线程的分配。比如一个线程调用同步方法method1获取到了锁，而method1中又调用了同步方法method2，
这时候线程不需要再次去获取当前对象的锁了，可以直接执行method2。
2、可中断锁：线程一直等待锁的过程中可以中断请求。在Java中，synchronized就不是可中断锁，而Lock是可中断锁。
3、公平锁：按照请求锁的顺序获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，
等待时间最久的线程（最先请求的线程）会获得该锁，这种就是公平锁。ReentrantLock和ReentrantReadWriteLock，
它默认情况下是非公平锁，但是可以设置为公平锁。synchronized是非公平锁。
4、读写锁：分成2个锁（读锁、写锁）ReadWriteLock、ReentrantReadWriteLock


