##################################面向对象################################
    面向对象： 面向对象顾名思义就是把现实中的事物都抽象成为程序设计中的“对象”，其基本思想是一切皆对象，
是一种“自下而上”的设计语言，先设计组件，再完成拼装。
    面向过程： 面向过程是“自上而下”的设计语言，先定好框架，再增砖添瓦。
通俗点，就是先定好main()函数，然后再逐步实现main()函数中所要用到的其他方法。
    面向对象就是高度实物抽象化、面向过程就是自顶向下的编程！

    某日小明上数学课，他的老师给了很多个不同的直角三角板让小明用尺子去量三角板的三个边，并将长度记录下来。两个小时过去，小明完成任务，把数据拿给老师。
老师给他说，还有一个任务就是观察三条边之间的数量关系。又是两个小时，聪明的小明连蹦带跳走进了办公室，说：“老师，我找到了，三条边之中有两条，它们的平方和约等于另外一条的平方。
”老师拍拍小明的头，“你今天学会了一个定理，勾股定理。它就是说直角三角形有两边平方和等于第三边的平方和”。
另一个故事，某日老师告诉小明“今天要教你一个定理，勾股定理。”小明说，“什么是勾股定理呢？”“勾股定理是说，直角三角形中有两条边的平方和等于第三边的平方。”
然后老师给了一大堆直角三角板给小明，让他去验证。两个小时后，小明告诉老师定理是正确的.
第一个故事说的是自底向上的设计分析方法，第二个故事说的是自顶而下的设计分析方法。
我们用领域建模DDD这种方式，从一个一个用例去推导然后建模一个的业务的方式是自底向上的方式。
而我们在抽象的角度去定义问题，然后问题拆解，这是一个自顶向下的方式。自顶向下最重要的是定义问题，而如何定义问题的前提是知道问题的定义。

1、Java是什么？
        一门面向对象编程语言（Object Oriented Programmer），不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，
        因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，
        允许程序员以优雅的思维方式进行复杂的编程 [1]  。
  Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点 [2]  。
  Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等

  计算机语言（computer language）指用于人与计算机之间通讯的语言，是人与计算机之间传递信息的介质。
  但是其概念比通用的编程语言要更广泛。例如，HTML是置标语言，也是计算机语言，但并不是编程语言

  编程语言：用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。
  一种计算机语言让程序员能够准确地定义计算机所需要使用的数据，并精确地定义在不同情况下所应当采取的行动

Java对象和类：

  对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为
  类：类是一个模板，它描述一类对象的行为和状态。
二、java的三大特性即是：封装 继承 多态
                    封装：（Encapsulation）：封装也称信息隐藏，是指利用抽象数据类型把数据和基于数据的操作封装起来，
                使其成为一个不可分割的整体，数据隐藏在抽象数据内部，尽可能的隐藏数据细节，只保留一些接口使其与外界发生联系。
                也就是说用户无需知道内部的数据和方法的具体实现细节，只需根据留在外部的接口进行操作就行。
                        |——优点：提高代码的安全性、提高代码的复用性、封装细节便于修改内部代码，提高可维护性、简化外部调用，便于调用者使用，便于扩展和协作
                    继承：继承就是子类继承父类的特征和行为使得子类对象（实例）具有父类的实例域和方法，（java中对象中的数据称为实例域（instance field））
                或子类从父类继承方法使得子类具有父类的相同行为
                        |——优点：提高代码的复用性，减小代码和数据的冗余度
                        |——缺点：继承用的多提高了程序的耦合性
                    多态：多态是同一行为具有不同表现形式或形态的能力，继承是多态的前提
                针对某个类型的方法的调用，其真正执行的方法取决于运行时期实际类型的方法
                        |——多态的特点：要有继承、要有重写、父类的引用指向子类的对象
                        |——多态的优点：可替换性，可扩充性，接口性，灵活性，简化性


 #####################################线程#################################

1、线程的生命周期
     新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建
    状态
     就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已
    具备了运行的条件，只是没分配到CPU资源
     运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线
    程的操作和功能
     阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中
    止自己的执行，进入阻塞状态
     死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束

                            sleep（）时间到 join()结束
                            获得同步锁notify()/notifyAll
                            resume()
                                     —— 阻塞<———
                                   |                 |
                                   |                 |sleep(long time) join()
                                   |                 |等待同步锁 wait() suspend()
                                   |                 |
                                   👇                |
                        start()       得到cpu资源
                 新建——————>就绪——————>运行——————>死亡
                                      <——————       stop()
                                      yield()或         Error或Exception
                                      失去cpu资源        run()执行完成

2、java中实现多线程

   同步：A线程要请求某个资源，但此资源正在被B资源使用中，因为同步机制的存在，A线程请求不到怎么办，A线程只能等待下去

   异步：A线程要请求某个资源，但是此资源正在被B资源使用中，因为没有同步机制存在，A线程仍然请求的到，A线程无序等待

   显然，同步是最安全的，最保险的。而异步不安全，容易导致死锁，这样一个线程死掉就会导致整个进程崩溃，但是没有同步机制的存在，性能会有所提升

   ① 继承Thread,重写里面的run方法
   ② 实现Runnable接口
   ③ 实现Callable接口
   ④ 使用线程池
   线程池：Java中开辟出了一种管理线程的概念，这个概念叫做线程池，从概念以及应用场景中，我们可以看出，
   线程池的好处，就是可以方便的管理线程，也可以减少内存的消耗。

3、java中可以使用同步机制来实现线程安全问题
    方法一：同步代码块
            synchronized(同步监视器){
            }
    方法二：同步方法
    方法三：使用Lock()锁

    对象锁也叫方法锁，是针对一个对象实例的，它只在该对象的某个内存位置声明一个标识该对象是否拥有锁，
所有它只会锁住当前的对象，而并不会对其他对象实例的锁产生任何影响，不同对象访问同一个被synchronized修饰的方法的时候不会阻塞,
    类锁是锁住整个类，当有多个线程来声明这个类的对象时候将会被阻塞，直到拥有这个类锁的对象呗销毁或者主动释放了类锁，
这个时候在被阻塞的线程被挑选出一个占有该类锁，声明该类的对象。其他线程继续被阻塞住

4、Object.wait()：释放当前对象锁，并进入阻塞队列
   Object.notify()：唤醒当前对象阻塞队列里的任一线程（并不保证唤醒哪一个）
   Object.notifyAll()：唤醒当前对象阻塞队列里的所有线程

   synchronized 的含义：
       Java中每一个对象都可以成为一个监视器（Monitor）, 该Monitor由一个锁（lock）, 一个等待队列（waiting queue ）, 一个入口队列( entry queue)组成.
   对于一个对象的方法， 如果没有synchronized关键字， 该方法可以被任意数量的线程，在任意时刻调用。
   对于添加了synchronized关键字的方法，任意时刻只能被唯一的一个获得了对象实例锁的线程调用。
   synchronized用于实现多线程的同步操作


5、Object.wait(),Object.notify(),Object.notifyAll()都是Object的方法，
  为什么这三个方法要与synchronized一起使用呢？

 wait()的作用
       当一个线程在执行synchronized的方法内部，调用了wait()后， 该线程会释放该对象的锁，
   然后该线程会被添加到该对象的等待队列中（waiting queue）, 只要该线程在等待队列中，
   就会一直处于闲置状态， 不会被调度执行。 要注意wait()方法会强迫线程先进行释放锁操作，
   所以在调用wait()时， 该线程必须已经获得锁，否则会抛出异常。由于wait()在synchronized的方法内部被执行，
   锁一定已经获得， 就不会抛出异常了

 notify()的功用
      wait(), notify(), notifyAll() 和 synchronized 需要搭配使用， 用于线程同步
 当一个线程调用一个对象的notify()方法时， 调度器会从所有处于该对象等待队列（waiting queue）的线程中取出任意一个线程， 将其添加到入口队列( entry queue) 中.
 然后在入口队列中的多个线程就会竞争对象的锁， 得到锁的线程就可以继续执行。 如果等待队列中（waiting queue）没有线程， notify()方法不会产生任何作用
 notifyAll()和notify()工作机制一样， 区别在于notifyAll()会将等待队列（waiting queue）中所有的线程都添加到入口队列中（entry queue）
 注意, notifyAll()比notify()更加常用， 因为notify()方法只会唤起一个线程， 且无法指定唤醒哪一个线程，所以只有在多个执行相同任务的线程在并发运行时， 我们不关心哪一个线程被唤醒时，才会使用notify()

为什么这三个方法要与synchronized一起使用呢？解释这个问题之前，我们先要了解几个知识点

    每一个对象都有一个与之对应的监视器
    每一个监视器里面都有一个该对象的锁和一个等待队列和一个同步队列
    wait()方法的语义有两个，一是释放当前对象锁，另一个是进入阻塞队列，可以看到，这些操作都是与监视器相关的，
    当然要指定一个监视器才能完成这个操作了

notify()方法也是一样的，用来唤醒一个线程，你要去唤醒，首先你得知道他在哪儿，所以必须先找到该对象，
也就是获取该对象的锁，当获取到该对象的锁之后，才能去该对象的对应的等待队列去唤醒一个线程。值得注意的是，
只有当执行唤醒工作的线程离开同步块，即释放锁之后，被唤醒线程才能去竞争锁。

对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。
sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。
在调用sleep()方法的过程中，线程不会释放对象锁。
而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
从使用角度看，sleep是Thread线程类的方法，而wait是Object顶级类的方法。
sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用。
CPU及资源锁释放
sleep,wait调用后都会暂停当前线程并让出cpu的执行时间，但不同的是sleep不会释放当前持有的对象的锁资源，到时间后会继续执行，
而wait会放弃所有锁并需要notify/notifyAll后重新获取到对象锁资源后才能继续执行。
sleep和wait的区别：
1、sleep是Thread的静态方法，wait是Object的方法，任何对象实例都能调用。
2、sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁(即代码要在synchronized中)。
3、它们都可以被interrupted方法中断。

6、为什么要进行线程同步？

  　　 java允许多线程并发控制，当多个线程同时操作一个可共享资源变量时（如对其进行增删改查操作），
  会导致数据不准确，而且相互之间产生冲突。所以加入同步锁以避免该线程在没有完成操作前被其他线程调用，
  从而保证该变量的唯一性和准确性。


##################################操作系统有三种线程同步的方式#############################
  线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统-般有下面三种线程同步的方式:

  互斥量(Mutex): 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为.互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如Java 中的synchronized关键词和各种Lock 都是这种机制。
  信号量(Semphares) :它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
  事件(Event) : 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

7、死锁

  　　进程A中包含资源A,进程B中包含资源B，A的下一步需要资源B，B的下一步需要资源A，
  所以它们就互相等待对方占有的资源释放，所以也就产生了一个循环等待死锁。

　　死锁形成的必要条件总结（都满足之后就会产生）：

　　　　①、互斥条件：资源不能被共享，只能被同一个进程使用；

　　　　②、请求与保持条件：已经得到资源的进程可以申请新的资源;

　　　　③、不可剥夺条件：已经分配的资源不能从相应的进程中强制剥夺；

　　　　④、循环等待条件：系统中若干进程形成环路，该环路中每个进程都在等待相邻进程占用的资源。

#############################File类########################
注意：
    在main方法中加载文件，默认的文件位置是到工作空间下
    在测试方法中加载文件，默认的文件位置是在模块下
    一个汉字等于两个字符，在utf-8中一个中文占三个字节，特殊情况下有时候也会是四个字节


    其输出结果为3， 小伙伴们就要问了：“奇怪了，'字'这个字符，明明是三个字节，怎么可以用char类型的变量来表示？ char类型不是在java中是两个字节么？”

       其实，java中有外码和内码之分，顾名思义，外码就是JVM外部使用的编码，比如你在编辑器中输入的“字”，
   假设是UTF-8编码，UTF-8是变长编码，一个中文可能是1-3个字节来表示；那么，在JVM中，用的都是Unicode码，
   这是定长编码，所有字符都统一使用两个字节表示，这就是Java的内码。

   向char[]中赋值时会覆盖之前的值，不能完全覆盖原有值的话，剩下的值还在数组中
